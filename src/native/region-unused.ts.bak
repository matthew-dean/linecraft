// SIMPLIFIED Region rendering - back to first principles
// 
// Core approach:
// 1. Reserve N lines at bottom of terminal
// 2. Save cursor position at end (our anchor)
// 3. To render: restore cursor, move up N lines, render each line, save cursor
// 4. Disable auto-wrap globally
// 5. Truncate content to width before writing
// 6. Use diff to only update changed lines

import { diffFrames, type DiffOp } from './diff';
import * as ansi from './ansi';
import { RenderBuffer } from './buffer';
import { Throttle } from './throttle';
import { getTerminalWidth, getTerminalHeight, onResize } from '../utils/terminal';

export interface RegionOptions {
  width?: number;
  height?: number;
  stdout?: NodeJS.WriteStream;
  disableRendering?: boolean;
  // Optional callback to re-render the last component (for keep-alive during pause)
  onKeepAlive?: () => void;
}

export class TerminalRegion {
  private width: number;
  private height: number;
  private pendingFrame: string[] = [];
  private previousFrame: string[] = [];
  private throttle: Throttle;
  private renderBuffer: RenderBuffer;
  private stdout: NodeJS.WriteStream;
  private disableRendering: boolean;
  private isInitialized: boolean = false;
  private resizeCleanup?: () => void;
  private widthExplicitlySet: boolean;
  // Optional callback to re-render the last component (for keep-alive during pause)
  private onKeepAlive?: () => void;

  constructor(options: RegionOptions = {}) {
    this.widthExplicitlySet = options.width !== undefined;
    this.width = options.width ?? getTerminalWidth();
    this.height = options.height ?? 1;
    this.stdout = options.stdout ?? process.stdout;
    this.disableRendering = options.disableRendering ?? false;
    this.onKeepAlive = options.onKeepAlive;

    // Initialize frames
    this.pendingFrame = Array(this.height).fill('');
    this.previousFrame = Array(this.height).fill('');

    this.throttle = new Throttle(30); // Lower FPS for stability
    this.renderBuffer = new RenderBuffer(this.stdout);

    if (!this.disableRendering) {
      this.initializeRegion();
      if (!this.widthExplicitlySet) {
        this.setupResizeHandler();
      }
      this.setupExitHandler();
    }
  }

  private initializeRegion(): void {
    if (this.isInitialized) return;

    // SIMPLIFIED: Save cursor position (wherever we are)
    // This is our anchor point - we'll restore to here and move up to render
    this.stdout.write(ansi.SAVE_CURSOR);

    // Disable auto-wrap globally
    this.stdout.write(ansi.DISABLE_AUTO_WRAP);

    // Reserve space by printing newlines (moves cursor down)
    // This ensures we have the lines reserved
    for (let i = 0; i < this.height; i++) {
      this.stdout.write('\n');
    }

    // Re-save cursor after reserving lines (now at end of region)
    this.stdout.write(ansi.SAVE_CURSOR);

    this.isInitialized = true;
  }

  private setupAutoWrapKeepAlive(): void {
    // CRITICAL: Periodically re-render to keep auto-wrap disabled and re-establish content
    // Some terminals reset auto-wrap state, especially after resize or when idle
    // When paused (waiting for spacebar), we're not in an active render loop anymore,
    // so we need to keep rendering periodically to prevent auto-reflow
    // This is the same as the progress bar animation loop - continuous rendering
    // Check every 50ms - more frequent to catch resets faster, matching animation frequency
    this.autoWrapKeepAliveInterval = setInterval(() => {
      if (!this.disableRendering && this.isInitialized) {
        // CRITICAL: Re-disable auto-wrap FIRST (some terminals reset it)
        // Write directly to stdout to ensure it takes effect immediately
        this.stdout.write(ansi.DISABLE_AUTO_WRAP);
        
        // CRITICAL: If we have a callback to re-render the last component, use it
        // This re-renders flex/col components with current width (same as during animation)
        // If no callback, just re-render existing pendingFrame
        if (this.onKeepAlive) {
          this.onKeepAlive();
        } else {
          // Fallback: just re-render existing content
          this.renderNow();
        }
      }
    }, 50);
  }

  private setupResizeHandler(): void {
    this.resizeCleanup = onResize((newWidth, newHeight) => {
      // Re-disable auto-wrap (some terminals reset on resize)
      if (!this.disableRendering) {
        this.stdout.write(ansi.DISABLE_AUTO_WRAP);
      }

      if (!this.widthExplicitlySet) {
        this.width = newWidth;
      }

      // CRITICAL: Force immediate render (bypass throttle) to update with new size
      // This ensures we re-render even when paused/idle, preventing auto-reflow
      // Render IMMEDIATELY (no setTimeout) to fix any reflow as fast as possible
      // The terminal may have already reflowed content, but we fix it immediately
      
      // CRITICAL: Always read the latest width right before rendering
      // This ensures we never render with stale width, preventing chopping
      if (!this.widthExplicitlySet) {
        this.width = getTerminalWidth();
      }
      // Double-check one more time right before render
      const latestWidth = getTerminalWidth();
      if (!this.widthExplicitlySet && latestWidth !== this.width) {
        this.width = latestWidth;
      }
      
      // CRITICAL: If we have a callback to re-render the last content, use it
      // This re-renders ALL components (flex/col) with current width (same as during animation)
      // The region orchestrates this - components don't manage their own re-rendering
      // If no callback, just re-render existing pendingFrame
      if (this.onKeepAlive) {
        this.onKeepAlive();
      } else {
        // Fallback: just re-render existing content
        this.renderNow();
      }
    });
  }

  private setupExitHandler(): void {
    const cleanup = () => {
      if (this.isInitialized) {
        this.destroy();
      }
    };
    process.once('exit', cleanup);
    process.once('SIGINT', cleanup);
    process.once('SIGTERM', cleanup);
    process.once('uncaughtException', (error: Error, origin: NodeJS.UncaughtExceptionOrigin) => {
      cleanup();
      const originalListeners = process.listeners('uncaughtException');
      originalListeners.forEach((listener: NodeJS.UncaughtExceptionListener) => {
        listener(error, origin);
      });
    });
  }

  getWidth(): number {
    if (!this.widthExplicitlySet) {
      this.width = getTerminalWidth();
    }
    return this.width;
  }

  getHeight(): number {
    return this.height;
  }

  setLine(lineNumber: number, content: string): void {
    if (lineNumber < 1) {
      throw new Error('Line numbers start at 1');
    }

    const lineIndex = lineNumber - 1;

    // CRITICAL: Only expand if lineIndex is within reasonable bounds
    // If someone calls setLine with a very high number (e.g., from waitForSpacebar),
    // we should NOT expand the region - just ignore it or truncate
    // The region height should be controlled by the component layer, not by setLine calls
    if (lineIndex >= this.height) {
      // Only expand if it's not too far beyond current height (safety check)
      // This prevents accidental expansion from stray setLine calls
      // Limit expansion to at most 10 lines beyond current height
      const maxAllowedHeight = this.height + 10;
      if (lineIndex < maxAllowedHeight) {
        this.expandTo(lineIndex + 1);
      } else {
        // Line number is way too high - expand to max allowed, then ignore the rest
        this.expandTo(maxAllowedHeight);
        // Don't update the line if it's beyond max allowed
        return;
      }
    }

    // Ensure pending frame has enough lines (but don't let it grow unbounded)
    while (this.pendingFrame.length <= lineIndex && this.pendingFrame.length < this.height + 10) {
      this.pendingFrame.push('');
    }

    // Only update if within bounds
    if (lineIndex < this.pendingFrame.length) {
      this.pendingFrame[lineIndex] = content;
    }

    // Schedule render
    this.scheduleRender();
  }

  private expandTo(newHeight: number): void {
    const oldHeight = this.height;
    this.height = newHeight;

    // Expand frames
    while (this.pendingFrame.length < newHeight) {
      this.pendingFrame.push('');
    }
    while (this.previousFrame.length < newHeight) {
      this.previousFrame.push('');
    }

    // Reserve additional lines if initialized
    if (this.isInitialized && newHeight > oldHeight && !this.disableRendering) {
      const additionalLines = newHeight - oldHeight;
      for (let i = 0; i < additionalLines; i++) {
        this.stdout.write('\n');
      }
      // Re-save cursor position after expansion
      this.stdout.write(ansi.SAVE_CURSOR);
    }
  }

  set(content: string): void {
    const lines = content.split('\n');
    
    if (lines.length > this.height) {
      this.expandTo(lines.length);
    }

    this.pendingFrame = [...lines];
    while (this.pendingFrame.length < this.height) {
      this.pendingFrame.push('');
    }

    this.scheduleRender();
  }

  getLine(lineNumber: number): string {
    if (lineNumber < 1) {
      throw new Error('Line numbers start at 1');
    }
    const lineIndex = lineNumber - 1;
    return this.pendingFrame[lineIndex] || '';
  }

  clear(): void {
    for (let i = 0; i < this.pendingFrame.length; i++) {
      this.pendingFrame[i] = '';
    }
    this.scheduleRender();
  }

  clearLine(lineNumber: number): void {
    this.setLine(lineNumber, '');
  }

  private scheduleRender(): void {
    if (this.disableRendering) {
      this.previousFrame = [...this.pendingFrame];
      return;
    }

    if (this.throttle.shouldRender()) {
      this.renderNow();
    }
  }

  /**
   * SIMPLIFIED RENDERING - back to basics
   * 
   * Uses absolute positioning based on terminal rows:
   * - Region is at bottom: starts at row (rows - height + 1), ends at row (rows)
   * - On resize, we recalculate using new rows value
   * 
   * 1. Calculate absolute row positions from terminal.rows
   * 2. Move to start of region using absolute positioning
   * 3. For each line: clear, write (truncated), move to start, move down
   * 4. Save cursor position at end
   */
  renderNow(): void {
    if (this.disableRendering) {
      this.previousFrame = [...this.pendingFrame];
      return;
    }

    if (!this.isInitialized) {
      this.initializeRegion();
    }

    // CRITICAL: Don't prevent concurrent renders - the throttle handles that
    // Removing isRendering check to prevent duplicates
    // The throttle will naturally prevent too-frequent renders

    // CRITICAL: Always disable auto-wrap before rendering
    // Write directly to stdout to ensure it takes effect immediately
    // This is especially important after resize when terminal might have reset state
    // We ALWAYS keep auto-wrap disabled - never re-enable it (except on destroy)
    // This prevents auto-reflow even when idle/paused
    this.stdout.write(ansi.DISABLE_AUTO_WRAP);
    this.renderBuffer.write(ansi.HIDE_CURSOR);

    // SIMPLIFIED: Use SAVE/RESTORE cursor positioning
    // Restore to saved position (end of region), then move up to start
    this.renderBuffer.write(ansi.RESTORE_CURSOR);
    if (this.height > 0) {
      this.renderBuffer.write(ansi.moveCursorUp(this.height));
    }
    this.renderBuffer.write(ansi.MOVE_TO_START_OF_LINE);

    // CRITICAL: Only render exactly height lines, no more
    // pendingFrame might have more lines if setLine was called with high line numbers
    // But we should ONLY render up to this.height lines
    // DON'T truncate pendingFrame - it might contain content beyond height that will be
    // rendered when height is expanded. Just ensure we have enough lines.
    while (this.pendingFrame.length < this.height) {
      this.pendingFrame.push('');
    }
    const linesToRender = this.height;
    
    // Render each line
    for (let i = 0; i < linesToRender; i++) {
      const content = this.pendingFrame[i] || '';

      // Clear the line
      this.renderBuffer.write(ansi.CLEAR_LINE);
      this.renderBuffer.write(ansi.MOVE_TO_START_OF_LINE);
      
      // CRITICAL: Reset colors to prevent color bleeding from previous line
      // This ensures each line starts with a clean color state
      this.renderBuffer.write(ansi.RESET);

      // CRITICAL: Always use the latest width for truncation
      // Re-read width right before truncating to prevent chopping during resize
      // This is especially important when paused (waiting for spacebar)
      const currentWidth = this.widthExplicitlySet ? this.width : getTerminalWidth();
      
      // Truncate content to width (strip ANSI to measure, then truncate preserving ANSI)
      const plainContent = content.replace(/\x1b\[[0-9;]*m/g, '');
      let contentToWrite = content;
      if (plainContent.length > currentWidth) {
        let visualPos = 0;
        let charPos = 0;
        while (charPos < content.length && visualPos < currentWidth) {
          if (content[charPos] === '\x1b') {
            let ansiEnd = charPos + 1;
            while (ansiEnd < content.length) {
              if (content[ansiEnd] === 'm') {
                ansiEnd++;
                break;
              }
              if ((content[ansiEnd] >= '0' && content[ansiEnd] <= '9') || 
                  content[ansiEnd] === ';' || 
                  content[ansiEnd] === '[') {
                ansiEnd++;
              } else {
                break;
              }
            }
            charPos = ansiEnd;
          } else {
            charPos++;
            visualPos++;
          }
        }
        contentToWrite = content.substring(0, charPos);
      }

      // Write content
      this.renderBuffer.write(contentToWrite);

      // Move to start of line
      this.renderBuffer.write(ansi.MOVE_TO_START_OF_LINE);

      // Move down to next line (unless last line)
      if (i < linesToRender - 1) {
        this.renderBuffer.write(ansi.moveCursorDown(1));
      }
    }

    // We're now at the start of the last rendered line
    // Move down 1 to get to the line after the region
    if (linesToRender > 0) {
      this.renderBuffer.write(ansi.moveCursorDown(1));
    }

    // Re-save cursor position (now at end of region, ready for next render)
    this.renderBuffer.write(ansi.SAVE_CURSOR);

    // Show cursor
    this.renderBuffer.write(ansi.SHOW_CURSOR);

    // Flush
    this.renderBuffer.flush();

    // Update previous frame
    this.previousFrame = [...this.pendingFrame];
  }

  flush(): void {
    this.renderNow();
  }

  destroy(clearFirst: boolean = false): void {
    if (!this.isInitialized) return;

    if (clearFirst) {
      this.clear();
      this.renderNow();
    }

    // Re-enable auto-wrap
    if (!this.disableRendering) {
      this.stdout.write(ansi.ENABLE_AUTO_WRAP);
    }

    // Check if all lines are blank
    const allLinesBlank = this.previousFrame.every(line => line.trim() === '');
    
    if (allLinesBlank && this.height > 0) {
      // Restore cursor, move to start of region, delete lines
      this.renderBuffer.write(ansi.RESTORE_CURSOR);
      this.renderBuffer.write(ansi.moveCursorUp(this.height));
      this.renderBuffer.write(ansi.MOVE_TO_START_OF_LINE);
      this.renderBuffer.write(ansi.deleteLines(this.height));
      this.renderBuffer.flush();
    }

    if (this.resizeCleanup) {
      this.resizeCleanup();
    }

    this.isInitialized = false;
  }
}

